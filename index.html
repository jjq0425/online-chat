<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Channel Chat</title>
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Socket.io Client -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* éšè—æ»šåŠ¨æ¡ä½†ä¿æŒåŠŸèƒ½ */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        [v-cloak] {
            display: none;
        }

        /* èŠå¤©æ»šåŠ¨æ¡ï¼šç»†ã€åœ†è§’ã€é»˜è®¤éšè—ï¼Œhover æ˜¾ç¤º */
        .chat-scrollbar {
            /* Firefox */
            scrollbar-width: thin;
            scrollbar-color: transparent transparent;
        }

        .chat-scrollbar:hover {
            scrollbar-color: rgba(100, 116, 139, 0.35) transparent;
        }

        /* WebKit browsers */
        .chat-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .chat-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-scrollbar::-webkit-scrollbar-thumb {
            background: transparent;
            border-radius: 9999px;
            transition: background-color 160ms ease-in-out;
        }

        .chat-scrollbar:hover::-webkit-scrollbar-thumb {
            background: rgba(100, 116, 139, 0.35);
        }

        .chat-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(100, 116, 139, 0.6);
        }

        /* å‘é€è€…å¤´åƒä¸åç§°æ ·å¼ */
        .sender-avatar {
            width: 28px;
            height: 28px;
            border-radius: 9999px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: 600;
        }

        .sender-name {
            font-size: 13px;
            font-weight: 400;
            color: #334155;
            /* slate-700 */
        }

        .sender-meta {
            font-size: 11px;
            color: #94a3b8;
            /* gray-400 */
        }

        /* è¡Œä¸ºé¢æ¿å¯¹é½è¾…åŠ© */
        .action-panel.align-left {
            left: 0;
            right: auto;
        }

        .action-panel.align-right {
            right: 0;
            left: auto;
        }

        /* å¼•ç”¨è·³è½¬é—ªçƒæ•ˆæœ */
        @keyframes flash-bg {
            from {
                background-color: rgba(250, 204, 21, 0.6);
            }

            60% {
                background-color: rgba(250, 204, 21, 0.2);
            }

            to {
                background-color: transparent;
            }
        }

        .flash-highlight {
            animation: flash-bg 1000ms ease-out;
        }
    </style>
</head>

<body class="bg-gray-100 h-screen overflow-hidden flex flex-col font-sans text-slate-800">

    <div id="app" v-cloak class="flex flex-col h-full max-w-2xl mx-auto bg-white shadow-xl relative w-full">

        <!-- é¡¶éƒ¨æ  -->
        <header class="bg-white border-b border-gray-200 px-4 py-3 flex justify-between items-center shadow-sm z-10">
            <div class="flex items-center gap-2">
                <div class="w-2 h-2 rounded-full" :class="connected ? 'bg-green-500' : 'bg-red-500'"></div>
                <div class="leading-none">
                    <h1 class="font-bold text-lg text-gray-800">å®æ—¶è¯Šç–—</h1>
                    <div class="text-gray-400 text-xs">#{{ channelId }}</div>
                </div>
            </div>
            <div class="text-xs text-gray-500 flex flex-col items-end">
                <span v-if="isSimulationMode"
                    class="text-amber-600 bg-amber-50 px-2 py-0.5 rounded border border-amber-200 mb-1">é¢„è§ˆæ¨¡å¼
                    (æœ¬åœ°å­˜å‚¨)</span>
                <span>å½“å‰ç”¨æˆ·: {{ username }} <span v-if="userid" class="text-gray-400">({{ userid }})</span></span>
                <span class="text-gray-400 text-[10px]">{{ mode === 'view' ? 'ä»…æŸ¥çœ‹æ¨¡å¼' : 'å®æ—¶äº¤æµæ¨¡å¼' }}</span>
            </div>
        </header>

        <!-- èŠå¤©å†…å®¹åŒºåŸŸ -->
        <main ref="chatContainer" class="flex-1 overflow-y-auto p-4 space-y-4 bg-gray-50/50 chat-scrollbar">
            <div v-if="messages.length === 0" class="text-center text-gray-400 mt-10 text-sm">
                æš‚æ— æ¶ˆæ¯ï¼Œå¼€å§‹èŠå¤©å§...
            </div>

            <div v-for="(msg, index) in messages" :key="index" :id="`msg-${msg.messageId || msg.clientId || index}`"
                class="flex flex-col gap-1 transition-all duration-300 ease-in-out group"
                :class="isSelf(msg.sender) ? 'items-end' : 'items-start'">

                <!-- å‘é€è€…ä¿¡æ¯ (å¦‚æœæ˜¯è‡ªå·±åˆ™ä¸æ˜¾ç¤ºåå­—ï¼Œæˆ–è€…æ˜¾ç¤ºåœ¨å³ä¾§) -->
                <div class="ml-1">
                    <div :class="['flex items-baseline gap-2', isSelf(msg) ? 'flex-row-reverse' : 'flex-row']"
                        @mouseenter="handleMessageHover(msg, $event)" @mouseleave="handleMessageLeave(msg, $event)">
                        <div class="sender-name"
                            :style="{ color: isSelf(msg) ? '#94a3b8' : getColorForId(msg.userid || msg.sender), fontWeight: '400' }">
                            {{ msg.sender }}</div>
                        <div class="sender-meta">{{ formatTime(msg.time) }}</div>

                        <!-- three-dot and action panel placed next to time; visible on row hover -->
                        <div class="relative" v-if="!msg.retracted&&mode!=='view'">
                            <button @click.prevent="togglePanel(msg, $event)"
                                class="panel-toggle text-gray-500 w-6 h-6 flex items-center justify-center opacity-0 group-hover:opacity-100 pointer-events-none group-hover:pointer-events-auto transition-opacity duration-150"
                                aria-label="æ›´å¤šæ“ä½œ">â‹¯</button>
                            <div :class="['action-panel', msg._panelOpen ? 'flex' : 'hidden', msg._panelAlign === 'left' ? 'align-left' : (msg._panelAlign === 'right' ? 'align-right' : '' ), 'flex-row', 'items-center', 'gap-2', 'p-2', 'bg-white', 'border', 'border-gray-200', 'rounded', 'shadow-md', 'absolute', 'top-full', 'mt-2', 'w-max']"
                                style="z-index:99999;">
                                <template v-if="canRecall(msg)">
                                    <button @click.prevent="recall(msg)"
                                        class="text-xs px-2 py-1 rounded hover:bg-gray-100 text-red-600">æ’¤å›</button>
                                    <div class="w-px h-4 bg-gray-200 mx-1"></div>
                                </template>
                                <!-- å¼•ç”¨æŒ‰é’® -->
                                <button @click.prevent="startQuote(msg)"
                                    class="text-xs px-2 py-1 rounded hover:bg-gray-100">å¼•ç”¨</button>
                                <div class="w-px h-4 bg-gray-200 mx-1"></div>
                                <button @click.prevent="react(msg, 'like')"
                                    class="text-xs px-2 py-1 rounded hover:bg-gray-100">ğŸ‘</button>
                                <button @click.prevent="react(msg, 'disagree')"
                                    class="text-xs px-2 py-1 rounded hover:bg-gray-100">ğŸ‘</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- æ°”æ³¡ -->
                <div @contextmenu.prevent="openPanel(msg, $event)"
                    class="max-w-[80%] rounded-2xl px-4 py-2 shadow-sm text-sm break-words relative group"
                    :class="isSelf(msg) ? 'bg-blue-100 text-slate-800 rounded-br-none' : 'bg-white text-gray-800 border border-gray-100 rounded-bl-none'">

                    <!-- è‹¥å·²æ’¤å›åˆ™å±•ç¤ºå ä½ï¼Œå¦åˆ™å±•ç¤ºæ­£å¸¸å†…å®¹ä¸ååº”æ§ä»¶ -->
                    <template v-if="msg.retracted">
                        <p class="text-gray-400 italic">æ¶ˆæ¯å·²æ’¤å›</p>
                    </template>
                    <template v-else>
                        <!-- å¼•ç”¨é¢„è§ˆï¼ˆå¯ç‚¹å‡»è·³è½¬å¹¶é—ªçƒç›®æ ‡æ¶ˆæ¯ï¼‰ -->
                        <div v-if="msg.quotedMessageId" class="mb-2">
                            <div v-if="getQuotedMessage(msg) && !getQuotedMessage(msg).retracted"
                                @click="scrollToMessage(msg.quotedMessageId)"
                                class="cursor-pointer p-2 bg-gray-50 rounded border-l-2 border-gray-200 text-xs text-gray-600 hover:bg-gray-100">
                                <div class="font-medium text-[12px] text-gray-700">{{ getQuotedMessage(msg).sender }}
                                </div>
                                <div class="truncate">{{ getQuotedPreviewText(getQuotedMessage(msg)) }}</div>
                            </div>
                            <div v-else
                                class="p-2 bg-gray-50 rounded text-xs text-gray-400 italic border-l-2 border-gray-200">
                                æ¶ˆæ¯å·²æ’¤å›</div>
                        </div>
                        <!-- æ–‡æœ¬æ¶ˆæ¯ -->
                        <p v-if="msg.type === 'text'" class="whitespace-pre-wrap">{{ msg.content }}</p>

                        <!-- å›¾ç‰‡æˆ–æ–‡ä»¶æ¶ˆæ¯ï¼šè‹¥ä¸º image/* åˆ™å±•ç¤ºå›¾ç‰‡ï¼Œå¦åˆ™å±•ç¤ºæ–‡ä»¶å¡ç‰‡ -->
                        <div
                            v-if="(msg.type === 'image') || (msg.type === 'file' && isObject(msg.content) && msg.content.mimeType && msg.content.mimeType.startsWith('image/'))">
                            <img :src="isObject(msg.content) ? fileUrl(msg.content) : msg.content"
                                class="max-w-full rounded-lg cursor-pointer hover:opacity-90 transition"
                                @click="openImage(isObject(msg.content) ? fileUrl(msg.content) : msg.content)"
                                alt="å‘é€çš„å›¾ç‰‡">
                        </div>

                        <!-- æ™®é€šæ–‡ä»¶å¡ç‰‡ -->
                        <div v-else-if="msg.type === 'file'" class="flex flex-col gap-1">
                            <div class="flex items-center gap-3 bg-gray-50 p-2 rounded-lg border border-gray-100">
                                <i data-lucide="file-text" class="w-6 h-6 text-gray-600"></i>
                                <div class="flex-1 min-w-0">
                                    <a :href="fileUrl(msg.content)" target="_blank"
                                        class="block text-sm text-blue-600 truncate underline">
                                        <span v-if="isObject(msg.content)">{{ msg.content.originalName }}</span>
                                        <span v-else>{{ extractName(msg.content) }}</span>
                                    </a>
                                    <div class="text-[11px] text-gray-500">{{ isObject(msg.content) ?
                                        (msg.content.mimeType
                                        || '') : '' }} Â· {{ formatSize(isObject(msg.content) ? msg.content.size : 0) }}
                                    </div>
                                </div>
                                <a :href="fileUrl(msg.content)" target="_blank"
                                    class="text-gray-500 hover:text-gray-700">
                                    <i data-lucide="download" class="w-5 h-5"></i>
                                </a>
                            </div>
                        </div>

                        <!-- å°è®¡æ•°ï¼šä»…å½“æ•°é‡>0 æ˜¾ç¤º -->
                        <div class="mt-2 flex items-center gap-2 text-xs text-gray-600">
                            <span v-if="reactionCount(msg, 'like') > 0">ğŸ‘ {{ reactionCount(msg, 'like') }}</span>
                            <span v-if="reactionCount(msg, 'disagree') > 0">ğŸ‘ {{ reactionCount(msg, 'disagree')
                                }}</span>
                            <!-- <span v-if="reactionCount(msg, 'done') > 0">âœ… {{ reactionCount(msg, 'done') }}</span> -->
                        </div>
                    </template>

                    <!-- action panel moved next to sender meta above; removed duplicate side panel -->
                </div>
            </div>
        </main>

        <!-- åº•éƒ¨è¾“å…¥æ¡† (ä»…èŠå¤©æ¨¡å¼æ˜¾ç¤º) -->
        <footer v-if="mode !== 'view'" class="bg-white border-t border-gray-200 p-3 z-20">
            <!-- å¼•ç”¨é¢„è§ˆï¼ˆå‘é€æ—¶æ˜¾ç¤ºï¼Œå¯å–æ¶ˆï¼‰ -->
            <div v-if="replyTo" class="mb-2 px-2">
                <div class="flex items-start gap-2 bg-gray-50 border border-gray-100 rounded p-2 text-xs">
                    <div class="flex-1 min-w-0">
                        <div class="text-[12px] text-gray-700 font-medium">å¼•ç”¨è‡ª {{ replyTo.sender }}</div>
                        <div class="text-[11px] text-gray-500 truncate">{{ getQuotedPreviewText(replyTo) }}</div>
                    </div>
                    <button @click.prevent="cancelQuote" class="text-xs text-gray-500 px-2">å–æ¶ˆ</button>
                </div>
            </div>
            <div
                class="flex items-end gap-2 bg-gray-100 rounded-xl p-2 border border-transparent focus-within:border-blue-300 focus-within:bg-white focus-within:shadow-sm transition-all">

                <!-- æ–‡ä»¶ä¸Šä¼ æŒ‰é’® -->
                <label
                    class="p-2 text-gray-400 hover:text-blue-600 cursor-pointer transition-colors rounded-full hover:bg-gray-100 flex-shrink-0 relative">
                    <i data-lucide="file" class="w-5 h-5"></i>
                    <input type="file" accept="*/*" class="hidden" @change="handleFileUpload" :disabled="isUploading">
                    <div v-if="isUploading" class="absolute inset-0 bg-white/80 flex items-center justify-center">
                        <div class="w-3 h-3 border-2 border-blue-600 border-t-transparent rounded-full animate-spin">
                        </div>
                    </div>
                </label>

                <!-- æ–‡æœ¬è¾“å…¥ -->
                <textarea ref="messageInput" v-model="inputText" @keydown="onInputKeydown"
                    placeholder="å‘é€æ¶ˆæ¯...(æŒ‰ä½ Shift + Enter æ¢è¡Œ)" rows="1"
                    class="flex-1 bg-transparent border-none focus:ring-0 text-sm py-2 px-1 resize-none max-h-24 outline-none no-scrollbar text-gray-700 placeholder-gray-400"
                    style="min-height: 2.5rem;"></textarea>

                <!-- å‘é€æŒ‰é’® -->
                <button type="button" @click="sendMessage" :disabled="!inputText.trim()"
                    class="p-2 bg-blue-600 text-white rounded-full hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-all shadow-md active:scale-95 flex-shrink-0">
                    <i data-lucide="send" class="w-4 h-4"></i>
                </button>
            </div>
        </footer>

        <!-- å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡† -->
        <div v-if="previewImage"
            class="fixed inset-0 z-50 bg-black/90 flex items-center justify-center p-4 backdrop-blur-sm"
            @click="previewImage = null">
            <img :src="previewImage"
                class="max-w-full max-h-full rounded shadow-2xl animate-in zoom-in-95 duration-200">
            <button class="absolute top-4 right-4 text-white hover:text-gray-300">
                <i data-lucide="x" class="w-8 h-8"></i>
            </button>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, onBeforeUnmount, computed, nextTick, watch } = Vue;

        // ================= é…ç½®åŒºåŸŸ =================
        // éƒ¨ç½²æ—¶å°†æ­¤å¤„æ”¹ä¸º falseï¼Œå¹¶é…ç½®æ­£ç¡®çš„ SERVER_URL
        const FORCE_SIMULATION_MODE = false;
        const SERVER_URL = 'http://localhost:3000';
        // ===========================================

        createApp({
            setup() {
                // çŠ¶æ€
                const messages = ref([]);
                const inputText = ref('');
                const isUploading = ref(false);
                const connected = ref(false);
                const previewImage = ref(null);
                const chatContainer = ref(null);
                const messageInput = ref(null);
                const replyTo = ref(null);

                // URL å‚æ•°è§£æ
                const urlParams = new URLSearchParams(window.location.search);
                // é»˜è®¤å€¼ç”¨äºé¢„è§ˆæ•ˆæœ
                const channelId = ref(urlParams.get('channelid') || 'demo-channel');
                const username = ref(urlParams.get('username') || 'Guest' + Math.floor(Math.random() * 1000));
                // æ”¯æŒå¤–éƒ¨ä¼ å…¥ useridï¼›è‹¥æ²¡æœ‰åˆ™é»˜è®¤ä½¿ç”¨ username ä½œä¸º userid
                const userid = ref(urlParams.get('userid') || username.value);
                const mode = ref(urlParams.get('mode') || 'chat'); // 'chat' or 'view'

                // åˆ¤æ–­æ˜¯å¦åœ¨ iframe ä¸­è¿è¡Œæˆ–å¤„äºé¢„è§ˆç¯å¢ƒ
                const isSimulationMode = ref(FORCE_SIMULATION_MODE);

                // Socket å®ä¾‹
                let socket = null;

                // æ»šåŠ¨åˆ°åº•éƒ¨
                const scrollToBottom = () => {
                    nextTick(() => {
                        if (chatContainer.value) {
                            chatContainer.value.scrollTop = chatContainer.value.scrollHeight;
                        }
                    });
                };

                // è¾“å…¥æ¡†æŒ‰é”®å¤„ç†ï¼šEnter å‘é€ï¼ŒShift+Enter æ’å…¥æ¢è¡Œ
                const onInputKeydown = (e) => {
                    try {
                        if (!e) return;
                        if (e.key !== 'Enter') return;
                        // Shift+Enter æ’å…¥æ¢è¡Œ
                        if (e.shiftKey) {
                            // é˜»æ­¢æµè§ˆå™¨é»˜è®¤åœ¨ textarea ä¸­æ’å…¥æ¢è¡Œä¸€æ¬¡ï¼Œé¿å…æˆ‘ä»¬æ‰‹åŠ¨æ’å…¥æ—¶å‡ºç°åŒæ¢è¡Œ
                            e.preventDefault();
                            const el = e.target;
                            if (!el) return;
                            const start = el.selectionStart || 0;
                            const end = el.selectionEnd || 0;
                            const val = el.value || '';
                            const newVal = val.substring(0, start) + '\n' + val.substring(end);
                            // æ›´æ–°å…ƒç´ ä¸ v-model
                            el.value = newVal;
                            inputText.value = newVal;
                            // å°†å…‰æ ‡ç§»åˆ°æ¢è¡Œå
                            nextTick(() => {
                                try { el.selectionStart = el.selectionEnd = start + 1; } catch (e) { }
                            });
                            return;
                        }
                        // æ— ä¿®é¥°é”®æ—¶é˜»æ­¢é»˜è®¤ï¼ˆé¿å… textarea è‡ªå¸¦è¡Œä¸ºï¼‰å¹¶å‘é€æ¶ˆæ¯
                        e.preventDefault();
                        sendMessage();
                    } catch (err) {
                        console.error('onInputKeydown error', err);
                    }
                };

                const isSelf = (senderOrMsg) => {
                    // å¯ä»¥ä¼ å…¥å­—ç¬¦ä¸²ï¼ˆsenderï¼‰æˆ–æ•´ä¸ª msg å¯¹è±¡
                    let id = '';
                    if (senderOrMsg && typeof senderOrMsg === 'object') {
                        id = senderOrMsg.userid || senderOrMsg.sender || '';
                    } else {
                        id = senderOrMsg || '';
                    }
                    // ä»¥ userid ä¸ºä¼˜å…ˆæ¯”å¯¹ï¼Œå…¶æ¬¡æ¯”å¯¹ usernameï¼ˆå‘åå…¼å®¹ï¼‰
                    return id === userid.value || id === username.value;
                };

                const formatTime = (isoString) => {
                    const date = new Date(isoString);
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                };

                // å¤´åƒé¦–å­—æ¯
                const avatarInitial = (id) => {
                    if (!id) return '?';
                    try {
                        return String(id).trim().charAt(0).toUpperCase();
                    } catch (e) {
                        return '?';
                    }
                };

                // åŸºäº id çš„ base64 ç”Ÿæˆç¨³å®šé¢œè‰²ï¼ˆHSLï¼‰ç”¨äºç”¨æˆ·åé¢œè‰²
                const getColorForId = (id) => {
                    if (!id) return '#7c8799';
                    try {
                        const s = String(id);
                        // base64 encode (utf-8 safe)
                        let b64 = '';
                        try {
                            b64 = btoa(unescape(encodeURIComponent(s)));
                        } catch (e) {
                            // fallback: use raw string
                            b64 = s;
                        }
                        let hash = 0;
                        for (let i = 0; i < b64.length; i++) {
                            hash = (hash * 31 + b64.charCodeAt(i)) % 360;
                        }
                        const hue = hash;
                        const sat = 64;
                        const light = 45;
                        return `hsl(${hue}, ${sat}%, ${light}%)`;
                    } catch (e) {
                        return '#7c8799';
                    }
                };

                // --- ä¸šåŠ¡é€»è¾‘ ---

                // å‘é€æ–‡æœ¬æ¶ˆæ¯
                const sendMessage = () => {
                    if (!inputText.value.trim()) return;

                    // ç”Ÿæˆå”¯ä¸€ clientId ç”¨äºä¹è§‚æ›´æ–°å’ŒæœåŠ¡å™¨å›æ‰§åŒ¹é…
                    const clientId = Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 9);
                    const payload = {
                        channelId: channelId.value,
                        username: username.value,
                        userid: userid.value,
                        content: inputText.value,
                        type: 'text',
                        clientId,
                        // å¦‚æœå½“å‰å¤„äºå¼•ç”¨æŸæ¡æ¶ˆæ¯ï¼Œæºå¸¦ quotedMessageId
                        quotedMessageId: replyTo.value ? (replyTo.value.messageId || replyTo.value.clientId) : undefined
                    };

                    // ä¹è§‚æ›´æ–°ï¼šç«‹å³æŠŠæ¶ˆæ¯æ¨å…¥åˆ—è¡¨ï¼ˆæ ‡è®°ä¸º pendingï¼‰
                    messages.value.push({
                        time: new Date().toISOString(),
                        sender: payload.username || payload.userid,
                        userid: payload.userid,
                        content: payload.content,
                        type: payload.type,
                        clientId: payload.clientId,
                        // include quotedMessageId for immediate UI preview when quoting
                        quotedMessageId: payload.quotedMessageId,
                        pending: true
                    });
                    scrollToBottom();

                    dispatchMessage(payload);
                    inputText.value = '';
                    // å‘é€åæ¸…ç†å¼•ç”¨çŠ¶æ€
                    replyTo.value = null;
                };

                // å‘é€æ–‡ä»¶ï¼ˆæ”¯æŒä»»æ„ç±»å‹ï¼‰
                const handleFileUpload = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    isUploading.value = true;

                    try {
                        let fileMeta = null;

                        if (isSimulationMode.value) {
                            // æ¨¡æ‹Ÿæ¨¡å¼ï¼šè½¬ Base64 å½“ä½œå¯è®¿é—® URL å¹¶ä¿ç•™å…ƒä¿¡æ¯
                            const dataUrl = await toBase64(file);
                            // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
                            await new Promise(r => setTimeout(r, 600));
                            fileMeta = {
                                url: dataUrl,
                                originalName: file.name,
                                mimeType: file.type,
                                size: file.size
                            };
                        } else {
                            // çœŸå®æ¨¡å¼ï¼šä¸Šä¼ åˆ° Node æœåŠ¡å™¨
                            const formData = new FormData();
                            formData.append('file', file);

                            const res = await fetch(`${SERVER_URL}/api/upload`, {
                                method: 'POST',
                                body: formData
                            });
                            const data = await res.json();
                            if (data && data.url) {
                                // è¿”å›çš„ data é‡ŒåŒ…å« url/originalName/mimeType/size
                                fileMeta = data;
                                // ä¿è¯ url ä¸ºç»å¯¹è·¯å¾„
                                if (!fileMeta.url.startsWith('http')) {
                                    fileMeta.url = SERVER_URL + fileMeta.url;
                                }
                            } else {
                                throw new Error('Upload failed');
                            }
                        }

                        // ç”Ÿæˆ clientId ç”¨äºä¹è§‚æ›´æ–°åŒ¹é…
                        const clientId = Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 9);

                        // ä¹è§‚æ›´æ–°ï¼ˆå°†æ–‡ä»¶æ¶ˆæ¯ç«‹å³åŠ å…¥æ¶ˆæ¯åˆ—è¡¨ï¼‰
                        messages.value.push({
                            time: new Date().toISOString(),
                            sender: username.value || userid.value,
                            userid: userid.value,
                            content: fileMeta,
                            type: 'file',
                            clientId,
                            // include quotedMessageId for optimistic preview
                            quotedMessageId: replyTo.value ? (replyTo.value.messageId || replyTo.value.clientId) : undefined,
                            pending: true
                        });
                        scrollToBottom();

                        // å‘é€æ–‡ä»¶æ¶ˆæ¯ï¼ˆcontent ä½¿ç”¨å¯¹è±¡ï¼ŒåŒ…å« url ä¸å…ƒæ•°æ®ï¼‰
                        const formData = new FormData();
                        formData.append('file', file);
                        formData.append('channelId', channelId.value);
                        formData.append('username', username.value);
                        formData.append('userid', userid.value);
                        formData.append('clientId', clientId);
                        // å¦‚æœå½“å‰å¼•ç”¨æŸæ¡æ¶ˆæ¯ï¼Œéšè¡¨å•æäº¤å¼•ç”¨ id
                        if (replyTo.value) formData.append('quotedMessageId', replyTo.value.messageId || replyTo.value.clientId || '');

                        await fetch(`${SERVER_URL}/api/upload`, {
                            method: 'POST',
                            body: formData
                        });
                        // å‘é€åæ¸…ç†å¼•ç”¨çŠ¶æ€
                        replyTo.value = null;

                    } catch (error) {
                        console.error('File upload failed:', error);
                        alert('æ–‡ä»¶å‘é€å¤±è´¥');
                    } finally {
                        isUploading.value = false;
                        e.target.value = ''; // é‡ç½® input
                    }
                };

                // ç»Ÿä¸€æ¶ˆæ¯åˆ†å‘ï¼ˆåŒºåˆ†çœŸå®ç¯å¢ƒå’Œæ¨¡æ‹Ÿç¯å¢ƒï¼‰
                const dispatchMessage = (payload) => {
                    if (isSimulationMode.value) {
                        // --- æ¨¡æ‹Ÿé€»è¾‘ ---
                        const mockMsg = {
                            ...payload,
                            time: new Date().toISOString(),
                            sender: payload.username || payload.userid,
                            userid: payload.userid || payload.username
                        };

                        // å­˜å…¥ LocalStorage
                        const key = `chat_logs_${channelId.value}`;
                        const logs = JSON.parse(localStorage.getItem(key) || '[]');
                        logs.push(mockMsg);
                        localStorage.setItem(key, JSON.stringify(logs));

                        // æ¨¡æ‹Ÿæ¥æ”¶ï¼ˆç›´æ¥æ¨å…¥å½“å‰æ•°ç»„ï¼‰
                        // å¦‚æœæ¨¡æ‹Ÿæ¶ˆæ¯åŒ…å« clientIdï¼Œå°è¯•æ›¿æ¢å·²æœ‰ pending æ¶ˆæ¯
                        if (mockMsg.clientId) {
                            const idx = messages.value.findIndex(m => m.clientId === mockMsg.clientId);
                            if (idx !== -1) {
                                messages.value.splice(idx, 1, mockMsg);
                            } else {
                                messages.value.push(mockMsg);
                            }
                        } else {
                            messages.value.push(mockMsg);
                        }
                        scrollToBottom();
                    } else {
                        // --- çœŸå® Socket.io é€»è¾‘ ---
                        if (socket) {
                            socket.emit('message', payload);
                        }
                    }
                };

                const openImage = (src) => {
                    previewImage.value = src;
                };

                // è¾…åŠ©å‡½æ•°ï¼šFile -> Base64
                const toBase64 = (file) => new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });

                // è¾…åŠ©ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºå¯¹è±¡ï¼ˆæ–‡ä»¶å…ƒä¿¡æ¯ï¼‰
                const isObject = (v) => v && typeof v === 'object' && !Array.isArray(v);

                // è¾…åŠ©ï¼šè¿”å›æ–‡ä»¶è®¿é—® URLï¼ˆæ”¯æŒ content ä¸º string æˆ– objectï¼‰
                const fileUrl = (content) => {
                    if (!content) return '#';
                    if (isObject(content)) {
                        const u = content.url || '';
                        return u.startsWith('http') ? u : SERVER_URL + u;
                    }
                    return (content || '').startsWith('http') ? content : SERVER_URL + content;
                };

                // è¾…åŠ©ï¼šä»è·¯å¾„æˆ– url ä¸­æå–æ–‡ä»¶å
                const extractName = (url) => {
                    if (!url) return '';
                    try {
                        const parts = url.split('/');
                        return parts[parts.length - 1];
                    } catch (e) {
                        return url;
                    }
                };

                // è¾…åŠ©ï¼šæ ¼å¼åŒ–å­—èŠ‚æ•°
                const formatSize = (bytes) => {
                    if (!bytes) return '';
                    const units = ['B', 'KB', 'MB', 'GB'];
                    let i = 0;
                    let val = bytes;
                    while (val >= 1024 && i < units.length - 1) {
                        val = val / 1024;
                        i++;
                    }
                    return `${val.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
                };

                // --- æ‹‰å–/è½®è¯¢é€»è¾‘ï¼ˆç”¨äºæ›¿ä»£åˆ·æ–°ï¼‰ ---
                let isFetching = false;

                // ç”Ÿæˆæ¶ˆæ¯å”¯ä¸€é”®ï¼ˆç”¨äºå»é‡ï¼‰ï¼šä¼˜å…ˆä½¿ç”¨ clientIdï¼Œå…¶æ¬¡ä½¿ç”¨ time+userid+content æŒ‡çº¹
                // ç”Ÿæˆæ¶ˆæ¯å”¯ä¸€é”®ï¼ˆç”¨äºå»é‡ï¼‰ï¼šä¼˜å…ˆä½¿ç”¨ messageIdï¼Œå…¶æ¬¡ clientIdï¼Œå…¶æ¬¡ time+userid+content æŒ‡çº¹
                const messageKey = (m) => {
                    if (!m) return '';
                    if (m.messageId) return `id:${m.messageId}`;
                    if (m.clientId) return `c:${m.clientId}`;
                    const uid = m.userid || m.sender || '';
                    let c = '';
                    try {
                        c = typeof m.content === 'object' ? JSON.stringify(m.content) : String(m.content);
                    } catch (e) {
                        c = String(m.content);
                    }
                    return `t:${m.time}|u:${uid}|c:${c}`;
                };

                // ä»åç«¯æ‹‰å–å†å²å¹¶åˆå¹¶ï¼ˆä¿ç•™æœ¬åœ° pending æœªç¡®è®¤çš„æ¶ˆæ¯ï¼‰
                const fetchHistory = async () => {
                    if (isFetching) return;
                    isFetching = true;
                    try {
                        const res = await fetch(`${SERVER_URL}/api/history/${encodeURIComponent(channelId.value)}`);
                        if (!res.ok) return;
                        const logs = await res.json();

                        const seen = new Set();
                        const merged = [];
                        for (const lg of logs) {
                            const k = messageKey(lg);
                            if (!seen.has(k)) {
                                seen.add(k);
                                merged.push(lg);
                            }
                        }

                        // æŠŠæœ¬åœ° pending æ¶ˆæ¯ï¼ˆæœªè¢«æœåŠ¡ç«¯æŒä¹…åŒ–ï¼‰è¿½åŠ åˆ°åˆ—è¡¨æœ«å°¾
                        for (const m of messages.value) {
                            if (m.pending) {
                                const k = messageKey(m);
                                if (!seen.has(k)) {
                                    merged.push(m);
                                }
                            }
                        }

                        messages.value = merged;
                        scrollToBottom();
                    } catch (e) {
                        console.error('fetchHistory error', e);
                    } finally {
                        isFetching = false;
                    }
                };

                // åˆå¹¶å•æ¡ç”± websocket æ¨é€è¿‡æ¥çš„æ¶ˆæ¯ï¼š
                // - è‹¥åŒ…å« clientIdï¼Œå°è¯•æ›¿æ¢æœ¬åœ° pending æ¶ˆæ¯
                // - å¦åˆ™æ ¹æ® messageKey å»é‡åè¿½åŠ 
                const mergeMessage = (m) => {
                    if (!m) return;
                    try {
                        // å¦‚æœæœ‰ clientIdï¼Œä¼˜å…ˆæ›¿æ¢ pending
                        // å¦‚æœæœ‰ messageId æˆ– clientIdï¼Œå°è¯•æ›¿æ¢å·²æœ‰ pending
                        if (m.messageId) {
                            const idx = messages.value.findIndex(x => x.messageId === m.messageId || x.clientId === m.clientId);
                            if (idx !== -1) {
                                messages.value.splice(idx, 1, m);
                                scrollToBottom();
                                return;
                            }
                        }
                        if (m.clientId) {
                            const idx2 = messages.value.findIndex(x => x.clientId === m.clientId);
                            if (idx2 !== -1) {
                                messages.value.splice(idx2, 1, m);
                                scrollToBottom();
                                return;
                            }
                        }

                        const k = messageKey(m);
                        const exists = messages.value.some(x => messageKey(x) === k);
                        if (!exists) {
                            messages.value.push(m);
                            scrollToBottom();
                        }
                    } catch (e) {
                        console.error('mergeMessage error', e);
                    }
                };

                // reaction è®¡æ•°ï¼ˆå®‰å…¨è¯»å–ï¼‰
                const reactionCount = (m, action) => {
                    if (!m || !m.reactions) return 0;
                    const arr = m.reactions[action];
                    if (!Array.isArray(arr)) return 0;
                    return arr.length;
                };

                // è§¦å‘ reactionï¼ˆé€šè¿‡ socket å‘ç»™åç«¯ï¼Œåç«¯ä¼šåˆ‡æ¢å¹¶å¹¿æ’­æ›´æ–°ï¼‰
                const react = (msg, action) => {
                    if (isSimulationMode.value) {
                        // æœ¬åœ°æ¨¡æ‹Ÿï¼šç›´æ¥ä¿®æ”¹æœ¬åœ°å¹¶å­˜å‚¨
                        try {
                            const uid = userid.value;
                            if (!msg.reactions) msg.reactions = { like: [], disagree: [], done: [] };
                            const arr = msg.reactions[action] || [];
                            const exists = arr.indexOf(uid) !== -1;
                            if (exists) {
                                msg.reactions[action] = arr.filter(u => u !== uid);
                            } else {
                                msg.reactions[action] = Array.from(new Set(arr.concat([uid])));
                            }
                        } catch (e) {
                            console.error('local react error', e);
                        }
                        return;
                    }

                    if (!socket) return;
                    const messageId = msg.messageId || msg.clientId || null;
                    if (!messageId) return;
                    socket.emit('reaction', { channelId: channelId.value, messageId, userid: userid.value, action });
                };

                // åœæ­¢è½®è¯¢ï¼ˆå½“å‰ä½¿ç”¨ websocket-onlyï¼Œä¿ç•™ç©ºå®ç°ä»¥é˜²æ­¢æœªå®šä¹‰è°ƒç”¨ï¼‰
                const stopPolling = () => { };

                // åˆ¤æ–­å½“å‰ç”¨æˆ·æ˜¯å¦èƒ½æ’¤å›è¯¥æ¶ˆæ¯ï¼ˆæœ¬äººå¹¶ä¸”åœ¨ä¸¤åˆ†é’Ÿå†…ï¼‰
                const canRecall = (m) => {
                    try {
                        if (!m) return false;
                        // å¿…é¡»æ˜¯è‡ªå·±å‘çš„
                        if (!isSelf(m)) return false;
                        const t = new Date(m.time).getTime();
                        if (isNaN(t)) return false;
                        return (Date.now() - t) <= (2 * 60 * 1000);
                    } catch (e) {
                        return false;
                    }
                };

                // æ’¤å›æ¶ˆæ¯ï¼šé€šè¿‡ socket å‘é€ç»™åç«¯ï¼Œç”±åç«¯éªŒè¯å¹¶å¹¿æ’­æ›´æ–°
                const recall = (m) => {
                    if (isSimulationMode.value) {
                        try {
                            if (!m) return;
                            if (!isSelf(m)) return;
                            // æœ¬åœ°æ¨¡æ‹Ÿï¼šç›´æ¥æ ‡è®°ä¸ºæ’¤å›ï¼ˆæ²¡æœ‰æ—¶æ•ˆæ ¡éªŒï¼‰
                            m.retracted = true;
                        } catch (e) {
                            console.error('local recall error', e);
                        }
                        return;
                    }
                    if (!socket || !m) return;
                    const messageId = m.messageId || m.clientId || null;
                    if (!messageId) return;
                    socket.emit('recall', { channelId: channelId.value, messageId, userid: userid.value });
                };

                // é¼ æ ‡è¿›å…¥æ¶ˆæ¯è¡Œæ—¶ï¼Œæµ‹é‡é¢æ¿æ˜¯å¦ä¼šæº¢å‡ºå¹¶è‡ªåŠ¨è®¾ç½®ç¿»è½¬å¯¹é½
                const handleMessageHover = (msg, evt) => {
                    try {
                        // å¦‚æœæ˜¯ä»…æŸ¥çœ‹æ¨¡å¼ï¼Œä¸è¦å¤„ç†
                        if (mode.value === 'view') return;
                        if (!msg || !evt) return;
                        // å¦‚æœé¢æ¿å·²ç»æ‰“å¼€ï¼Œä¸è¦é‡æ–°è®¡ç®—ä½ç½®ï¼Œä¿æŒå›ºå®šï¼ˆé¿å…æŠ–åŠ¨ï¼‰
                        if (msg._panelOpen) return;
                        // æ”¯æŒç›´æ¥ä¼ å…¥å®¿ä¸»å…ƒç´ æˆ–æ ‡å‡†äº‹ä»¶å¯¹è±¡
                        const host = (evt instanceof Element) ? evt : (evt.currentTarget || null);
                        if (!host) return;
                        const panel = host.querySelector('.action-panel');
                        if (!panel) return;

                        // ä¸´æ—¶æ˜¾ç¤ºä»¥æµ‹é‡å°ºå¯¸ï¼ˆä½†ä¿æŒä¸å¯è§ï¼Œé¿å…é—ªçƒï¼‰
                        panel.classList.remove('hidden');
                        panel.style.visibility = 'hidden';

                        const panelRect = panel.getBoundingClientRect();
                        const hostRect = host.getBoundingClientRect();
                        const vw = window.innerWidth || document.documentElement.clientWidth;
                        const margin = 18; // ä¿æŒä¸€ç‚¹è§†å£è¾¹è·

                        let align = null;
                        if (isSelf(msg)) {
                            // é»˜è®¤å³å¯¹é½ï¼ˆè‡ªå·±çš„æ¶ˆæ¯åœ¨å³ä¾§ï¼‰ï¼Œä½†å¦‚æœå³å¯¹é½å¯¼è‡´å·¦ä¾§æº¢å‡ºåˆ™ç¿»è½¬ä¸ºå·¦å¯¹é½
                            const rightAlignedLeft = hostRect.right - panelRect.width;
                            if (rightAlignedLeft < margin) align = 'left';
                            else align = 'right';
                        } else {
                            // é»˜è®¤å·¦å¯¹é½ï¼ˆä»–äººçš„æ¶ˆæ¯åœ¨å·¦ä¾§ï¼‰ï¼Œä½†å¦‚æœå·¦å¯¹é½è¶…å‡ºè§†å£åˆ™ç¿»è½¬ä¸ºå³å¯¹é½
                            const leftAlignedRight = hostRect.left + panelRect.width;
                            if (leftAlignedRight > vw - margin) align = 'right';
                            else align = 'left';
                        }

                        // æ¢å¤çŠ¶æ€ï¼ˆå®é™…æ˜¾ç¤ºç”± CSS çš„ group-hover æ§åˆ¶ï¼‰ï¼Œå¹¶è®°å½•é€‰æ‹©çš„å¯¹é½æ–¹å¼
                        panel.style.visibility = '';
                        panel.classList.add('hidden');
                        msg._panelAlign = align;
                    } catch (e) {
                        console.error('handleMessageHover error', e);
                    }
                };

                const handleMessageLeave = (msg, evt) => {
                    try {
                        if (!msg) return;
                        // å»¶è¿Ÿæ¸…ç†ï¼Œé¿å…å¿«é€Ÿç§»åŠ¨å¯¼è‡´é—ªçƒ
                        // ä½†å¦‚æœé¢æ¿å·²æ‰“å¼€ï¼Œåˆ™ä¸è¦æ¸…ç†å¯¹é½ä¿¡æ¯ï¼ˆä¿æŒé¢æ¿ä½ç½®å›ºå®šï¼‰
                        setTimeout(() => {
                            if (msg && !msg._panelOpen) msg._panelAlign = null;
                        }, 80);
                    } catch (e) {
                        console.error('handleMessageLeave error', e);
                    }
                };

                // æŸ¥æ‰¾æ¶ˆæ¯å¯¹è±¡ï¼ˆæ”¯æŒ messageId æˆ– clientIdï¼‰
                const findMessageById = (id) => {
                    if (!id) return null;
                    return messages.value.find(m => m.messageId === id || m.clientId === id) || null;
                };

                const getQuotedMessage = (m) => {
                    if (!m || !m.quotedMessageId) return null;
                    return findMessageById(m.quotedMessageId);
                };

                const getQuotedPreviewText = (m) => {
                    if (!m) return '';
                    if (m.retracted) return 'æ¶ˆæ¯å·²æ’¤å›';
                    if (m.type === 'text') return m.content;
                    if (m.type === 'file' && isObject(m.content)) return m.content.originalName || extractName(m.content.url || '');
                    return m.type || '';
                };

                // å¹³æ»‘æ»šåŠ¨å¹¶é—ªçƒæŒ‡å®šæ¶ˆæ¯
                const scrollToMessage = (id) => {
                    if (!id) return;
                    const el = document.getElementById(`msg-${id}`);
                    if (!el) return;
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    try {
                        el.classList.remove('flash-highlight');
                        // å¼ºåˆ¶å›æµä»¥é‡è§¦å‘åŠ¨ç”»
                        void el.offsetWidth;
                        el.classList.add('flash-highlight');
                        setTimeout(() => el.classList.remove('flash-highlight'), 1200);
                    } catch (e) {
                        // ignore
                    }
                };

                // å¼€å§‹å¼•ç”¨æŸæ¡æ¶ˆæ¯ï¼ˆå°†çŠ¶æ€è®¾ç½®ä¸º replyTo å¹¶èšç„¦è¾“å…¥æ¡†ï¼‰
                const startQuote = (msg) => {
                    if (!msg) return;
                    replyTo.value = msg;
                    nextTick(() => {
                        try {
                            if (messageInput.value) messageInput.value.focus();
                        } catch (e) { }
                    });
                };

                const cancelQuote = () => {
                    replyTo.value = null;
                };

                // æ‰“å¼€/åˆ‡æ¢/å…³é—­é¢æ¿çš„è¾…åŠ©æ–¹æ³•
                const closeAllPanels = () => {
                    try {
                        for (const m of messages.value) {
                            if (m && m._panelOpen) m._panelOpen = false;
                        }
                    } catch (e) {
                        console.error('closeAllPanels error', e);
                    }
                };

                const openPanel = (msg, evt) => {
                    try {
                        if (!msg) return;
                        // å…ˆå…³é—­å…¶å®ƒé¢æ¿
                        closeAllPanels();
                        // è®¡ç®—å¯¹é½ï¼šæ‰¾åˆ°åŒ…å« `.action-panel` çš„æœ€é è¿‘çš„å®¿ä¸»å…ƒç´ ï¼Œç¡®ä¿
                        // æ— è®ºæ˜¯é€šè¿‡ç‚¹å‡»ä¸‰ç‚¹è¿˜æ˜¯å³é”®æ°”æ³¡ï¼Œæµ‹é‡é€»è¾‘éƒ½é’ˆå¯¹ç›¸åŒå®¿ä¸»
                        const findPanelHost = (startNode) => {
                            try {
                                let n = startNode instanceof Element ? startNode : (startNode && startNode.target ? startNode.target : null);
                                while (n && n !== document) {
                                    if (n.querySelector && n.querySelector('.action-panel')) return n;
                                    n = n.parentElement;
                                }
                            } catch (e) {
                                // ignore
                            }
                            return null;
                        };

                        let host = null;
                        if (evt) host = findPanelHost(evt.target || evt.currentTarget);
                        // fallback: try currentTarget or document-level group
                        if (!host && evt && evt.currentTarget) host = findPanelHost(evt.currentTarget) || (evt.currentTarget.closest ? evt.currentTarget.closest('.group') : null);
                        if (!host && evt && evt.target) host = findPanelHost(evt.target) || (evt.target.closest ? evt.target.closest('.group') : null);
                        // æœ€ç»ˆå›é€€ä¸ºæ•´ä¸ª message çš„ .group
                        if (!host && evt && evt.target) host = (evt.target.closest ? evt.target.closest('.group') : null);

                        handleMessageHover(msg, host || (evt && evt.currentTarget) || null);
                        msg._panelOpen = true;
                    } catch (e) {
                        console.error('openPanel error', e);
                    }
                };

                const togglePanel = (msg, evt) => {
                    try {
                        if (!msg) return;
                        if (msg._panelOpen) {
                            msg._panelOpen = false;
                            return;
                        }
                        // æ‰“å¼€å‰å…ˆå…³é—­å…¶ä»–æ‰€æœ‰é¢æ¿
                        closeAllPanels();
                        const findPanelHost = (startNode) => {
                            try {
                                let n = startNode instanceof Element ? startNode : (startNode && startNode.target ? startNode.target : null);
                                while (n && n !== document) {
                                    if (n.querySelector && n.querySelector('.action-panel')) return n;
                                    n = n.parentElement;
                                }
                            } catch (e) {
                                // ignore
                            }
                            return null;
                        };

                        let host = null;
                        if (evt) host = findPanelHost(evt.target || evt.currentTarget);
                        if (!host && evt && evt.currentTarget) host = findPanelHost(evt.currentTarget) || (evt.currentTarget.closest ? evt.currentTarget.closest('.group') : null);
                        if (!host && evt && evt.target) host = findPanelHost(evt.target) || (evt.target.closest ? evt.target.closest('.group') : null);
                        if (!host && evt && evt.target) host = (evt.target.closest ? evt.target.closest('.group') : null);

                        handleMessageHover(msg, host || (evt && evt.currentTarget) || null);
                        msg._panelOpen = true;
                    } catch (e) {
                        console.error('togglePanel error', e);
                    }
                };

                // ç‚¹å‡»é¡µé¢ä»»æ„éé¢æ¿åŒºåŸŸæ—¶å…³é—­æ‰€æœ‰é¢æ¿
                const handleOutsideClick = (e) => {
                    try {
                        // å¦‚æœç‚¹å‡»å‘ç”Ÿåœ¨é¢æ¿å†…éƒ¨æˆ–åˆ‡æ¢æŒ‰é’®ä¸Šï¼Œåˆ™å¿½ç•¥ï¼ˆä¸å…³é—­ï¼‰
                        if (e.target.closest && (e.target.closest('.action-panel') || e.target.closest('.panel-toggle'))) return;
                        closeAllPanels();
                    } catch (err) {
                        console.error('handleOutsideClick error', err);
                    }
                };

                // åˆå§‹åŒ–
                onMounted(() => {
                    lucide.createIcons();

                    if (isSimulationMode.value) {
                        console.log('Running in Simulation Mode');
                        connected.value = true;
                        // åŠ è½½å†å²è®°å½•
                        const key = `chat_logs_${channelId.value}`;
                        const savedLogs = JSON.parse(localStorage.getItem(key) || '[]');
                        messages.value = savedLogs;
                        scrollToBottom();

                        // æ¨¡æ‹Ÿâ€œåˆ«äººâ€å‘æ¶ˆæ¯çš„ç›‘å¬ï¼ˆä½¿ç”¨ storage event è·¨æ ‡ç­¾é¡µåŒæ­¥ï¼‰
                        window.addEventListener('storage', (e) => {
                            if (e.key === key) {
                                const newLogs = JSON.parse(e.newValue || '[]');
                                if (newLogs.length > messages.value.length) {
                                    // ç®€å•çš„å…¨é‡æ›´æ–°é€»è¾‘
                                    messages.value = newLogs;
                                    scrollToBottom();
                                }
                            }
                        });

                    } else {
                        // è¿æ¥çœŸå®åç«¯
                        socket = io(SERVER_URL);

                        socket.on('connect', () => {
                            connected.value = true;
                            socket.emit('join', channelId.value);
                            // å‘ŠçŸ¥æœåŠ¡ç«¯å½“å‰ç”¨æˆ· idï¼ˆsocket è¿æ¥çº§åˆ«ï¼Œå¯é€‰ï¼‰
                            socket.emit('identify', { userid: userid.value, username: username.value });
                            // è¿æ¥åè§¦å‘ä¸€æ¬¡å†å²æ‹‰å–
                            fetchHistory();
                        });

                        socket.on('disconnect', () => {
                            connected.value = false;
                            // no-op: polling removed, rely on websocket pushes
                        });

                        socket.on('history', (logs) => {
                            // ç›´æ¥ä½¿ç”¨æœåŠ¡ç«¯å†å²ï¼ˆè¦†ç›–æœ¬åœ°ï¼‰ï¼Œå¹¶ä¿ç•™ pending
                            fetchHistory();
                        });

                        socket.on('newMessage', (msg) => {
                            // æ”¶åˆ°å•æ¡æ–°æ¶ˆæ¯ï¼Œåˆå¹¶åˆ°æœ¬åœ°ï¼ˆæ›¿æ¢ pending æˆ–è¿½åŠ ï¼‰
                            mergeMessage(msg);
                        });

                        socket.on('updateMessage', (msg) => {
                            // æœåŠ¡ç«¯å¹¿æ’­çš„æ¶ˆæ¯æ›´æ–°ï¼ˆä¾‹å¦‚ reactions å˜æ›´ï¼‰
                            mergeMessage(msg);
                        });

                        // è¿æ¥æˆåŠŸåï¼ˆconnect å›è°ƒé‡Œä¹Ÿä¼šè§¦å‘ï¼‰ï¼Œæ— éœ€é‡å¤ fetchHistory here
                    }
                    // å…¨å±€ç‚¹å‡»ç›‘å¬ï¼Œç”¨äºå…³é—­æ‰“å¼€çš„é¢æ¿
                    document.addEventListener('click', handleOutsideClick);
                });

                onBeforeUnmount(() => {
                    stopPolling();
                    if (socket) socket.disconnect();
                    document.removeEventListener('click', handleOutsideClick);
                });

                return {
                    messages,
                    inputText,
                    sendMessage,
                    onInputKeydown,
                    handleFileUpload,
                    isUploading,
                    channelId,
                    username,
                    userid,
                    mode,
                    isSelf,
                    formatTime,
                    chatContainer,
                    connected,
                    previewImage,
                    openImage,
                    isSimulationMode,
                    messageInput,
                    replyTo,
                    startQuote,
                    cancelQuote,
                    findMessageById,
                    getQuotedMessage,
                    getQuotedPreviewText,
                    scrollToMessage,
                    // helpers for template
                    isObject,
                    fileUrl,
                    extractName,
                    formatSize,
                    avatarInitial,
                    getColorForId
                    , reactionCount,
                    react,
                    stopPolling,
                    canRecall,
                    recall,
                    handleMessageHover,
                    handleMessageLeave,
                    openPanel,
                    togglePanel,
                    closeAllPanels
                };
            }
        }).mount('#app');
    </script>
</body>

</html>